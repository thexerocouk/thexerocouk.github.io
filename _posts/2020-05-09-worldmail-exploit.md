---
layout: post
title:  Worldmail Exploit
date:	2020-05-09 
author: TheXero
comments: true
categories: exploit-development
description:  The first public exploit we released was for the Eudora Qualcomm IMAP server, commonly known as Worldmail. This exploit was classified as a Structured Exception Handler (SEH) buffer ...
excerpt: The first public exploit we released was for the Eudora Qualcomm IMAP server commonly known as Worldmail. This exploit was classified as a Structured Exception Handler (SEH) buffer ...
tags: [exploit, development, hacking, stack, shellcode, seh]
thumbnail: /images/exploit-development-worldmail-200x200.png
image: /images/exploit-development-worldmail.png
---

The first public exploit we released was for the Eudora Qualcomm IMAP server, commonly known as Worldmail. This exploit was classified as a Structured Exception Handler (SEH) buffer overflow, and can be triggered from an unauthenticated internet based attacker.

This write-up will detail the technicalities behind the exploit, and also the learning opportunties faced while developing our first public exploit.

Firstly, a server-side SEH overflow vulnerability can be represented with the following pseudocode:

    try
        accept a socket connection
        accept input
        do something with the input  <-- too much input - goto except
    except 
        return an error message to the socket <-- crash happens here

An SEH overflow will cause some sort of exception within the exception handling code. When the controllable input is placed within the exception handler and is not handled appropriately, this may lead to more than one possible outcome. As attackers, we would want the target application to crash.

Now I know what you are thinking, <b>a crash is useless, I want a shell!</b> If it crashes using our crafted input, there is a possibility that we can control the crash. By controling the crash, instead of terminating the application, we may be able to determine what code is being executed instead.

In the Worldmail example, the crash occurs when the application is attempting to process the data between the braces <b>{</b>. After approximately 769 characters within the braces, you start to overwrite the <b>SEH</b> chain.

The resulting psudocode would resemble the following:

    {
    1
    2
    ...
    768
    769
    NSEH <-- 4 bytes
    SEH <-- 4 bytes
    }

The <b>NSEH</b> is intended to point to the address of the next exception handler. Overwriting this alone probably won't achieve attacker much in terms of code execution. However, you will notice that <b>SEH</b> is right next to <b>NSEH</b>, this is the one you want to control in most circumstances.

Back in the day, you could overwrite the <b>SEH</b> to point to a <b>JMP</b> instruction and land at your shellcode. From Windows XP SP2, the steps required a little more effort, a mitigation was introduced that would fill all of the registers with <b>00000000</b> when an exception occurred. This meant that you could not merely <b>JMP</b> to your shellcode anymore. 

Instead, we had to find a way to perform a series of <b>POP</b> instructions, to remove the nulls from the top of the stack. Fortunately for us, the exact <b>POP; POP; RETN;</b> series of instructions was found within an included Worldmail DLL. This was considered a WIN for us. Not only would we have demonstrated we can now control the program execution flow, but we are also now able to place code within the <b>NSEH</b> which will be executed following the <b>PPR</b>.

However, the <b>NSEH</b> is only 4 bytes in size, if we make the size any larger, it will affect our <b>SEH</b> offset. Fortunately for us, 4 bytes is large enough for a <b>SHORT JMP</b> byte sequence. We want this <b>SHORT JMP</b> sequence to allow us to jump over the <b>SEH</b>, where we can place some more code. 

So far, the pseudocode resembled the following:

    {
    1
    2
    ...
    768
    769
    SHORT JMP
    PPR
    SHELLCODE
    }

Now we are getting somewhere, we can now trigger the <b>SEH</b> overflow, control the execution flow and perform a <b>PPR</b> and land back to our code stored within the <b>NSEH</b>. This code will now perform a <b>SHORT JMP</b> over the <b>SEH</b> and land in our shellcode.

The problem we now face, is that bindshell shellcode is typically >300 bytes in size. Our available space for our shellcode is not nearly enough.

We do however, have a total of 769 bytes of space inside our initial buffer before we hit the <b>NSEH</b>, so if we can create, or use some existing code to jump back into our initial buffer, we can store a bindshell there.

Rather than perform the calculation to jump back far enough, we decided it would be more fun to use Matt Millers <a href="http://hick.org/code/skape/papers/egghunt-shellcode.pdf" target="_blank">egghunt-shellcode</a> instead. If you are interested in how this works, we suggest reading the linked PDF document.

Our final pseudocode exploit would resemble the following:

    {
    1
    2
    ...
    EGG
    SHELLCODE
    ...
    768
    769
    SHORT JMP
    PPR
    EGGHUNTER
    }

The full original exploit code can be found at the following Exploit-DB URL.
<a href="https://www.exploit-db.com/exploits/18354" target="_blank">https://www.exploit-db.com/exploits/18354</a>

Since this exploit was created, the code has proven reliable, the kind hoped for, but less expected of public code. What we have noticed however, is that the <b>INT 2E</b> Windows syscall does not perform the same function it previously did. As a result, on the latest versions of Windows, this exploit code may not be as reliable as it once was. 

Fortunately however, an updated version of the exploit has been included within the available exploits as part of the nullsploit exploitation engine. This can be found within the tools section of this site, or at the following link: [nullsploit-engine]({% post_url 2019-05-03-nullsploit-engine %}).

